use nom::{
    branch::alt,
    bytes::streaming::{tag, take_until, take_while, take_while_m_n},
    combinator::{map, map_res, opt},
    sequence::{delimited, pair, terminated, tuple},
    IResult,
};
use std::fmt::Formatter;

// Type is generated by parse_ciphertexts, which is currently unused
#[allow(dead_code)]
type ParsedCiphertext<'a> = (
    bool, // debug
    Option<CiphertextVersion>,
    Option<Datatype>,
    &'a [u8], // iv
    &'a [u8], // public key
    &'a [u8], // encrypted value
);

pub fn find_ciphertext_prefix(input: &[u8]) -> IResult<&[u8], &[u8]> {
    take_until("ev:")(input)
}

pub fn parse_ciphertexts(input: &[u8]) -> IResult<&[u8], Option<Ciphertext>> {
    opt(context_aware_ciphertext)(input)
}

fn ciphertext(input: &[u8]) -> IResult<&[u8], Ciphertext> {
    map(
        delimited(
            tuple((ciphertext_prefix, ciphertext_delimiter)),
            tuple((
                map(opt(pair(debug, ciphertext_delimiter)), |debug_flag| {
                    debug_flag.is_some()
                }),
                opt(terminated(version, ciphertext_delimiter)),
                opt(terminated(datatype, ciphertext_delimiter)),
                terminated(ciphertext_iv, ciphertext_delimiter),
                terminated(ciphertext_public_key, ciphertext_delimiter),
                terminated(ciphertext_encrypted_value, ciphertext_delimiter),
            )),
            ciphertext_suffix,
        ),
        Ciphertext::from,
    )(input)
}

fn context_aware_ciphertext(input: &[u8]) -> IResult<&[u8], Ciphertext> {
    map(
        tuple((
            map(opt(quote), |maybe_quote| maybe_quote.is_some()),
            ciphertext,
            map(opt(quote), |maybe_quote| maybe_quote.is_some()),
        )),
        |parsed| {
            let (leading_quote, mut ciphertext, trailing_quote) = parsed;
            ciphertext.set_leading_quote(leading_quote);
            ciphertext.set_trailing_quote(trailing_quote);
            ciphertext
        },
    )(input)
}

#[derive(Debug)]
pub struct Ciphertext {
    debug: bool,
    version: Option<CiphertextVersion>,
    datatype: Option<Datatype>,
    iv: Vec<u8>,
    public_key: Vec<u8>,
    encrypted_value: Vec<u8>,
    has_leading_quote: bool,
    has_trailing_quote: bool,
}

impl<'a> std::convert::From<ParsedCiphertext<'a>> for Ciphertext {
    fn from(parsed: ParsedCiphertext<'a>) -> Self {
        Self::new(parsed, false, false)
    }
}

impl Ciphertext {
    fn new(parsed: ParsedCiphertext, has_leading_quote: bool, has_trailing_quote: bool) -> Self {
        let (debug, version, datatype, iv, pub_key, encrypted_val) = parsed;

        Self {
            debug,
            version,
            datatype,
            iv: iv.to_vec(),
            public_key: pub_key.to_vec(),
            encrypted_value: encrypted_val.to_vec(),
            has_leading_quote,
            has_trailing_quote,
        }
    }

    pub fn set_leading_quote(&mut self, has_leading_quote: bool) {
        self.has_leading_quote = has_leading_quote;
    }

    fn set_trailing_quote(&mut self, has_trailing_quote: bool) {
        self.has_trailing_quote = has_trailing_quote;
    }

    /// All EV ciphertexts are strings, which will result in them being wrapped in quotes in JSON payloads
    /// If the decrypted value is a non-string, then we should remove the quotes
    pub fn should_discard_quotes(&self) -> bool {
        self.is_in_quotes()
            && self
                .datatype
                .as_ref()
                .map(|dt| !dt.is_string())
                .unwrap_or(false)
    }

    pub fn is_in_quotes(&self) -> bool {
        self.has_leading_quote() && self.has_trailing_quote()
    }

    pub fn has_leading_quote(&self) -> bool {
        self.has_leading_quote
    }

    pub fn has_trailing_quote(&self) -> bool {
        self.has_trailing_quote
    }

    // Ciphertext cannot be empty but len is dependent on the encrypted value and needs to be computed
    #[allow(clippy::len_without_is_empty)]
    pub fn len(&self) -> usize {
        // prefix len
        3 + self.version.as_ref().map(|_| 5).unwrap_or(0) // version + delimiter
            + self.datatype.as_ref().map(|dt| dt.len() + 1).unwrap_or(0) // type + delimiter
            + self.iv.len()
            + 1 // delimiter
            + self.public_key.len()
            + 1 // delimiter
            + self.encrypted_value.len()
            + 2 // delimiter + suffix
            + if self.is_in_quotes() { 2 } else { 0 } // quotes offset
            + if self.debug { 6 } else { 0 }
    }
}

impl std::fmt::Display for Ciphertext {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "ev:")?;
        if self.debug {
            write!(f, "debug:")?;
        }
        if let Some(vers) = self.version.as_ref() {
            write!(f, "{vers}:")?;
        }
        if let Some(datatype) = self.datatype.as_ref() {
            write!(f, "{datatype}:")?;
        }
        write!(
            f,
            "{}:{}:{}:$",
            std::str::from_utf8(self.iv.as_slice()).expect("IV validated by parser"),
            std::str::from_utf8(self.public_key.as_slice())
                .expect("Public Key validated by parser"),
            std::str::from_utf8(self.encrypted_value.as_slice())
                .expect("Encrypted value validated by parser")
        )
    }
}

fn quote(input: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b"\"")(input)
}

fn ciphertext_prefix(input: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b"ev")(input)
}

fn ciphertext_delimiter(input: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b":")(input)
}

fn ciphertext_iv(input: &[u8]) -> IResult<&[u8], &[u8]> {
    take_while_m_n(16, 16, is_base64)(input)
}

fn ciphertext_public_key(input: &[u8]) -> IResult<&[u8], &[u8]> {
    take_while_m_n(44, 44, is_base64)(input)
}

fn ciphertext_encrypted_value(input: &[u8]) -> IResult<&[u8], &[u8]> {
    take_while(is_base64)(input)
}

fn ciphertext_suffix(input: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b"$")(input)
}

fn is_base64(input: u8) -> bool {
    input.is_ascii_alphanumeric() || input == b'=' || input == b'/' || input == b'+'
}

fn version(input: &[u8]) -> IResult<&[u8], CiphertextVersion> {
    // match against any of the valid version tags
    map_res(
        alt((tag(b"RFVC"), tag(b"T1JL"), tag(b"Tk9D"), tag(b"TENZ"), tag(b"QlJV"))),
        CiphertextVersion::try_from,
    )(input)
}

fn debug(input: &[u8]) -> IResult<&[u8], &[u8]> {
    tag(b"debug")(input)
}

fn datatype(input: &[u8]) -> IResult<&[u8], Datatype> {
    // match against any of the valid version tags
    map_res(
        alt((tag(b"string"), tag(b"boolean"), tag(b"number"))),
        Datatype::try_from,
    )(input)
}

#[derive(Clone, Debug, PartialEq)]
enum CiphertextVersion {
    Rfvc,
    T1jl,
    Tk9d,
    Tenz,
    Qljv,
}

impl std::convert::TryFrom<&[u8]> for CiphertextVersion {
    type Error = ();

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let version = match value {
            b"RFVC" => CiphertextVersion::Rfvc,
            b"T1JL" => CiphertextVersion::T1jl,
            b"Tk9D" => CiphertextVersion::Tk9d,
            b"TENZ" => CiphertextVersion::Tenz,
            b"QlJV" => CiphertextVersion::Qljv,
            _ => return Err(()),
        };
        Ok(version)
    }
}

impl std::fmt::Display for CiphertextVersion {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Rfvc => "RFVC",
                Self::T1jl => "T1JL",
                Self::Tk9d => "Tk9D",
                Self::Tenz => "TENZ",
                Self::Qljv => "QlJV",
            }
        )
    }
}

#[derive(Clone, Debug, PartialEq)]
enum Datatype {
    Boolean,
    Number,
    String,
}

impl Datatype {
    fn len(&self) -> usize {
        match self {
            Self::Boolean => 7,
            Self::Number => 6,
            Self::String => 6,
        }
    }

    fn is_string(&self) -> bool {
        matches!(self, Self::String)
    }
}

impl std::convert::TryFrom<&[u8]> for Datatype {
    type Error = ();

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        let datatype = match value {
            b"boolean" => Datatype::Boolean,
            b"string" => Datatype::String,
            b"number" => Datatype::Number,
            _ => return Err(()),
        };
        Ok(datatype)
    }
}

impl std::fmt::Display for Datatype {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                Self::Boolean => "boolean",
                Self::Number => "number",
                Self::String => "",
            }
        )
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use std::io::Write;

    fn build_ciphertext(
        version: Option<&CiphertextVersion>,
        datatype: Option<&Datatype>,
        debug: bool,
    ) -> Vec<u8> {
        let mut ciphertext = Vec::new();
        ciphertext.write_all(b"ev:").unwrap();
        if debug {
            ciphertext.write_all(b"debug:").unwrap();
        }
        if let Some(version) = version.map(|v| v.to_string()) {
            ciphertext.write_all(version.as_bytes()).unwrap();
            ciphertext.write_all(b":").unwrap();
        }
        if let Some(dt) = datatype.map(|dt| dt.to_string()) {
            ciphertext.write_all(dt.as_bytes()).unwrap();
            ciphertext.write_all(b":").unwrap();
        }
        ciphertext.write_all(b"YGJVktHhdj3ds3wC:A6rkaTU8lez7NSBT8nTqbhBIu3tX4/lyH3aJVBUcGmLh:8hI5qEp32kWcVK367yaC09bDRbk:$").unwrap();
        ciphertext
    }

    macro_rules! build_ciphertext_test {
        ($ver:ident) => {
            let ciphertext_vec = build_ciphertext($ver.as_ref(), None, false);
            let (input, parsed_ciphertext) =
                ciphertext(ciphertext_vec.as_slice()).expect("No parse error");
            assert_eq!(input.len(), 0);
            assert_eq!(parsed_ciphertext.datatype, None);
            assert_eq!(parsed_ciphertext.version, $ver);
        };
        ($ver:ident,$dt:path) => {
            let ciphertext_vec = build_ciphertext($ver.as_ref(), Some(&$dt), false);
            let (input, parsed_ciphertext) =
                ciphertext(ciphertext_vec.as_slice()).expect("No parse error");
            assert_eq!(input.len(), 0);
            assert_eq!(parsed_ciphertext.datatype, Some($dt));
            assert_eq!(parsed_ciphertext.version, $ver);
        };
        ($ver:ident,$dt:path,$debug:literal) => {
            let ciphertext_vec = build_ciphertext($ver.as_ref(), Some(&$dt), $debug);
            let (input, parsed_ciphertext) =
                ciphertext(ciphertext_vec.as_slice()).expect("No parse error");
            assert_eq!(input.len(), 0);
            assert_eq!(parsed_ciphertext.datatype, Some($dt));
            assert_eq!(parsed_ciphertext.version, $ver);
            assert_eq!(parsed_ciphertext.debug, $debug);
        };
    }

    #[test]
    fn test_ciphertext_parse_with_no_version() {
        build_ciphertext_test!(None);
        build_ciphertext_test!(None, Datatype::Boolean);
        build_ciphertext_test!(None, Datatype::Number);
        build_ciphertext_test!(None, Datatype::Number, true);
    }

    #[test]
    fn test_ciphertext_parse_with_versions() {
        let tk9d = Some(CiphertextVersion::Tk9d);
        build_ciphertext_test!(tk9d);
        build_ciphertext_test!(tk9d, Datatype::Boolean);
        build_ciphertext_test!(tk9d, Datatype::Number);
        build_ciphertext_test!(tk9d, Datatype::Number, true);
        let t1jl = Some(CiphertextVersion::T1jl);
        build_ciphertext_test!(t1jl);
        build_ciphertext_test!(t1jl, Datatype::Boolean);
        build_ciphertext_test!(t1jl, Datatype::Number);
        build_ciphertext_test!(t1jl, Datatype::Number, true);
        let rfvc = Some(CiphertextVersion::Rfvc);
        build_ciphertext_test!(rfvc);
        build_ciphertext_test!(rfvc, Datatype::Boolean);
        build_ciphertext_test!(rfvc, Datatype::Number);
        build_ciphertext_test!(rfvc, Datatype::Number, true);
        let tenz = Some(CiphertextVersion::Tenz);
        build_ciphertext_test!(tenz);
        build_ciphertext_test!(tenz, Datatype::Boolean);
        build_ciphertext_test!(tenz, Datatype::Number);
        build_ciphertext_test!(tenz, Datatype::Number, true);
        let qljv = Some(CiphertextVersion::Qljv);
        build_ciphertext_test!(qljv);
        build_ciphertext_test!(qljv, Datatype::Boolean);
        build_ciphertext_test!(qljv, Datatype::Number);
        build_ciphertext_test!(qljv, Datatype::Number, true);
    }

    #[test]
    fn test_ciphertext_serialization() {
        let ciphertext_bytes = build_ciphertext(None, None, false);
        let (_, parsed) = ciphertext(ciphertext_bytes.as_slice()).unwrap();
        assert_eq!(
            parsed.to_string(),
            std::str::from_utf8(&ciphertext_bytes).unwrap().to_string()
        );
    }

    #[test]
    fn test_contextful_ciphertext_parsing() {
        let ciphertext_bytes = build_ciphertext(None, None, false);
        // test leading and trailing quotes
        let contextful_bytes =
            vec![b"\"".to_vec(), ciphertext_bytes.clone(), b"\"".to_vec()].concat();
        let (_, parsed) =
            context_aware_ciphertext(contextful_bytes.as_ref()).expect("no parsing error");
        assert!(parsed.has_leading_quote());
        assert!(parsed.has_trailing_quote());
        assert!(parsed.is_in_quotes());

        // test only leading
        let contextful_bytes =
            vec![b"\"".to_vec(), ciphertext_bytes.clone(), b" ".to_vec()].concat();
        let (_, parsed) =
            context_aware_ciphertext(contextful_bytes.as_ref()).expect("no parsing error");
        assert!(parsed.has_leading_quote());
        assert!(!parsed.has_trailing_quote());
        assert!(!parsed.is_in_quotes());

        // test only trailing
        let contextful_bytes = vec![ciphertext_bytes.clone(), b"\"".to_vec()].concat();
        let (_, parsed) =
            context_aware_ciphertext(contextful_bytes.as_ref()).expect("no parsing error");
        assert!(!parsed.has_leading_quote());
        assert!(parsed.has_trailing_quote());
        assert!(!parsed.is_in_quotes());

        // test no character following ciphertext - expect nom incomplete (to be handled by stream impl)
        let result = context_aware_ciphertext(ciphertext_bytes.as_ref());
        assert!(result.is_err());
        let returned_error = result.err().unwrap();
        assert!(returned_error.is_incomplete());
    }
}
